Вспомним самый базовый алгоритм поиска подстроки: для каждого окна размера $m$ в исходной строке $text$ проверяем каждый символ на равенство с символом в подстроке $pattern$. Если встречаем несовпадение, то сдвигаем окно на одну позицию вправо и повторяем проверку.

Хочется сдвигать окно больше чем на 1 символ. Тогда построим префикс функцию $\pi$ для подстроки $pattern$. На этапе проверки равенства символов в строке $pattern$ мы можем использовать префикс функцию для определения наибольшего префикса подстроки, который совпадает с суффиксом подстроки. В случае если для индекса j получили несовпадение символов в $pattern$ и $text$, то можем сдвинуть строку $pattern$ на $\pi[j - 1]$ позиций вправо. Затем продолжаем проверку начиная с индекса $\pi[j - 1]$ (индекс $i$ указывающий на строку $text$ остается на месте). 

### Общая сложность

Построение префикс функции имеет сложность $O(m)$ (строим за один проход по строке $pattern$), где $m$ - длина подстроки $pattern$. Проверка подстроки имеет сложность $O(n)$, где $n$ - длина строки $text$. Общая сложность алгоритма составляет $O(m + n)$.

Разберем подробнее сложность проверки подстроки. Индекс $i$ не уменьшается, индекс $j$ растёт вместе с индексом $i$, при этом также может уменьшаться в случае несовпадения символов в $pattern$ и $text$. В худшем случае, на изменение индекса j может уйти $2 \cdot n$ операций (max n операций на увеличение и n операций на уменьшение, т.к. не может опуститься ниже 0). Тогда общее количество операций не превышает $2 \cdot n$ и итоговая сложность $O(n)$.